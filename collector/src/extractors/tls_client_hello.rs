use nom::{
    combinator::complete,
    multi::{length_data, many0},
    number::streaming::be_u16,
    IResult,
};
use tls_parser::{parse_tls_extensions, TlsExtension, TlsMessage, TlsMessageHandshake};

const GREASE_TABLE: &[u16] = &[
    0x0a0a, 0x1a1a, 0x2a2a, 0x3a3a, 0x4a4a, 0x5a5a, 0x6a6a, 0x7a7a, 0x8a8a, 0x9a9a, 0xaaaa, 0xbaba,
    0xcaca, 0xdada, 0xeaea, 0xfafa,
];

#[derive(Debug, PartialEq)]
pub struct ClientHelloMetadata {
    /// Version of the outer TLS header
    pub outer_version: u16,
    /// Version in the client hello
    pub inner_version: u16,
    pub ciphers: Vec<u16>,
    pub extensions: Vec<u16>,
    pub sni: String,
    pub ec_curves: Vec<u16>,
    pub ec_curve_point_formats: Vec<u8>,
    pub alpn: Vec<String>,
}

impl ClientHelloMetadata {
    pub fn ja3(&self) -> String {
        // SSLVersion,Cipher,SSLExtension,EllipticCurve,EllipticCurvePointFormat
        format!(
            "{},{},{},{},{}",
            self.inner_version,
            self.ciphers
                .iter()
                .filter(|v| !GREASE_TABLE.contains(v))
                .map(u16::to_string)
                .collect::<Vec<_>>()
                .join("-"),
            self.extensions
                .iter()
                .filter(|v| !GREASE_TABLE.contains(v))
                .map(u16::to_string)
                .collect::<Vec<_>>()
                .join("-"),
            self.ec_curves
                .iter()
                .map(u16::to_string)
                .collect::<Vec<_>>()
                .join("-"),
            self.ec_curve_point_formats
                .iter()
                .map(u8::to_string)
                .collect::<Vec<_>>()
                .join("-"),
        )
    }
}

pub(crate) fn extract_client_hello(l4_content: &[u8]) -> Option<ClientHelloMetadata> {
    let (_rest, tls_plaintext) = tls_parser::parse_tls_plaintext(l4_content).ok()?;

    let outer_version = tls_plaintext.hdr.version.0;

    let client_hello = tls_plaintext.msg.iter().find_map(|msg| {
        if let TlsMessage::Handshake(TlsMessageHandshake::ClientHello(client_hello)) = msg {
            Some(client_hello)
        } else {
            None
        }
    })?;
    let inner_version = client_hello.version.0;
    let ciphers: Vec<_> = client_hello.ciphers.iter().map(|v| v.0).collect();

    let (_rest, extensions) = extract_extensions(client_hello.ext?).ok()?;

    let mut metadata = ClientHelloMetadata {
        outer_version,
        inner_version,
        ciphers,
        extensions,
        sni: String::new(),
        ec_curves: vec![],
        ec_curve_point_formats: vec![],
        alpn: vec![],
    };

    extract_extension_metadata(&mut metadata, client_hello.ext?)?;

    Some(metadata)
}

fn extract_extension_metadata(metadata: &mut ClientHelloMetadata, extensions: &[u8]) -> Option<()> {
    let (_rest, extensions) = parse_tls_extensions(extensions).ok()?;
    for extension in extensions {
        match extension {
            TlsExtension::SNI(sni_entries) => {
                if let Some((_sni_type, data)) = sni_entries.iter().copied().next() {
                    metadata.sni = String::from_utf8_lossy(data).into()
                }
            }
            TlsExtension::EllipticCurves(curves) => {
                metadata.ec_curves = curves
                    .into_iter()
                    .map(|curve| curve.0)
                    .filter(|v| !GREASE_TABLE.contains(v))
                    .collect();
            }
            TlsExtension::EcPointFormats(formats) => {
                metadata.ec_curve_point_formats = formats.into();
            }
            TlsExtension::Grease(_, _) => {}
            TlsExtension::ALPN(alpn) => {
                metadata.alpn = alpn
                    .into_iter()
                    .map(|slice| String::from_utf8_lossy(slice).to_string())
                    .collect();
            }
            _ => {}
        }
    }
    Some(())
}

fn extract_extensions(i: &[u8]) -> IResult<&[u8], Vec<u16>> {
    many0(complete(parse_tls_extension_id))(i)
}

pub fn parse_tls_extension_id(i: &[u8]) -> IResult<&[u8], u16> {
    let (i, ext_type) = be_u16(i)?;
    let (i, _ext_data) = length_data(be_u16)(i)?;
    Ok((i, ext_type))
}

#[cfg(test)]
mod tests {
    use pretty_assertions::assert_eq;

    use crate::extractors::tls_client_hello::{extract_client_hello, ClientHelloMetadata};

    const EXAMPLE_PACKET: &[u8] = &[
        0x60, 0x0e, 0x5b, 0xda, 0x02, 0x25, 0x06, 0x40, 0x2a, 0x02, 0x30, 0x35, 0x0b, 0x16, 0xe2,
        0x4b, 0x7e, 0xa0, 0x79, 0xa5, 0xf6, 0x72, 0x97, 0xd1, 0x26, 0x06, 0x28, 0x00, 0x02, 0x20,
        0x00, 0x01, 0x02, 0x48, 0x18, 0x93, 0x25, 0xc8, 0x19, 0x46, 0x98, 0xe4, 0x01, 0xbb, 0xc0,
        0xff, 0x3d, 0x0c, 0x9c, 0xed, 0x78, 0xec, 0x80, 0x18, 0x00, 0xfa, 0x84, 0xdb, 0x00, 0x00,
        0x01, 0x01, 0x08, 0x0a, 0x9b, 0xa6, 0xa8, 0x17, 0x2c, 0x82, 0x15, 0x3a, 0x16, 0x03, 0x01,
        0x02, 0x00, 0x01, 0x00, 0x01, 0xfc, 0x03, 0x03, 0x31, 0x42, 0x4f, 0x17, 0x39, 0x3d, 0x6e,
        0xd8, 0x01, 0xee, 0xfd, 0xe2, 0x9f, 0xcc, 0xe5, 0x0d, 0xbb, 0x91, 0x1d, 0xc9, 0xa1, 0xc9,
        0x06, 0x85, 0x15, 0xc7, 0xe4, 0xd2, 0x08, 0x2f, 0x81, 0x17, 0x20, 0x8d, 0x53, 0x82, 0x23,
        0x68, 0x6a, 0xb5, 0x0b, 0xb7, 0xe2, 0xf9, 0xab, 0x40, 0x94, 0xe6, 0xbf, 0xed, 0x7f, 0x21,
        0x7c, 0xe7, 0x1e, 0x8c, 0x69, 0x93, 0xfb, 0x0b, 0x07, 0xc0, 0xf2, 0x62, 0xbe, 0x00, 0x3e,
        0x13, 0x02, 0x13, 0x03, 0x13, 0x01, 0xc0, 0x2c, 0xc0, 0x30, 0x00, 0x9f, 0xcc, 0xa9, 0xcc,
        0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f, 0x00, 0x9e, 0xc0, 0x24, 0xc0, 0x28, 0x00, 0x6b,
        0xc0, 0x23, 0xc0, 0x27, 0x00, 0x67, 0xc0, 0x0a, 0xc0, 0x14, 0x00, 0x39, 0xc0, 0x09, 0xc0,
        0x13, 0x00, 0x33, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d, 0x00, 0x3c, 0x00, 0x35, 0x00, 0x2f,
        0x00, 0xff, 0x01, 0x00, 0x01, 0x75, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e, 0x00, 0x00, 0x0b,
        0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x00, 0x0b, 0x00, 0x04,
        0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x16, 0x00, 0x14, 0x00, 0x1d, 0x00, 0x17, 0x00,
        0x1e, 0x00, 0x19, 0x00, 0x18, 0x01, 0x00, 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04,
        0x00, 0x10, 0x00, 0x0e, 0x00, 0x0c, 0x02, 0x68, 0x32, 0x08, 0x68, 0x74, 0x74, 0x70, 0x2f,
        0x31, 0x2e, 0x31, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00,
        0x00, 0x0d, 0x00, 0x30, 0x00, 0x2e, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03, 0x08, 0x07, 0x08,
        0x08, 0x08, 0x1a, 0x08, 0x1b, 0x08, 0x1c, 0x08, 0x09, 0x08, 0x0a, 0x08, 0x0b, 0x08, 0x04,
        0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01, 0x03, 0x03, 0x03, 0x01, 0x03,
        0x02, 0x04, 0x02, 0x05, 0x02, 0x06, 0x02, 0x00, 0x2b, 0x00, 0x05, 0x04, 0x03, 0x04, 0x03,
        0x03, 0x00, 0x2d, 0x00, 0x02, 0x01, 0x01, 0x00, 0x33, 0x00, 0x26, 0x00, 0x24, 0x00, 0x1d,
        0x00, 0x20, 0xe0, 0x72, 0x9c, 0x10, 0x8c, 0x9a, 0x5e, 0xca, 0x0b, 0x3c, 0x24, 0x97, 0xad,
        0x7b, 0xda, 0x33, 0x6b, 0xb6, 0xb9, 0xc2, 0x0e, 0xcd, 0x24, 0x30, 0x09, 0x92, 0x09, 0x75,
        0x27, 0xec, 0x53, 0x01, 0x00, 0x15, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    const EXAMPLE_TLS_PAYLOAD: &[u8] = &[
        0x16, 0x03, 0x01, 0x02, 0x00, 0x01, 0x00, 0x01, 0xfc, 0x03, 0x03, 0x31, 0x42, 0x4f, 0x17,
        0x39, 0x3d, 0x6e, 0xd8, 0x01, 0xee, 0xfd, 0xe2, 0x9f, 0xcc, 0xe5, 0x0d, 0xbb, 0x91, 0x1d,
        0xc9, 0xa1, 0xc9, 0x06, 0x85, 0x15, 0xc7, 0xe4, 0xd2, 0x08, 0x2f, 0x81, 0x17, 0x20, 0x8d,
        0x53, 0x82, 0x23, 0x68, 0x6a, 0xb5, 0x0b, 0xb7, 0xe2, 0xf9, 0xab, 0x40, 0x94, 0xe6, 0xbf,
        0xed, 0x7f, 0x21, 0x7c, 0xe7, 0x1e, 0x8c, 0x69, 0x93, 0xfb, 0x0b, 0x07, 0xc0, 0xf2, 0x62,
        0xbe, 0x00, 0x3e, 0x13, 0x02, 0x13, 0x03, 0x13, 0x01, 0xc0, 0x2c, 0xc0, 0x30, 0x00, 0x9f,
        0xcc, 0xa9, 0xcc, 0xa8, 0xcc, 0xaa, 0xc0, 0x2b, 0xc0, 0x2f, 0x00, 0x9e, 0xc0, 0x24, 0xc0,
        0x28, 0x00, 0x6b, 0xc0, 0x23, 0xc0, 0x27, 0x00, 0x67, 0xc0, 0x0a, 0xc0, 0x14, 0x00, 0x39,
        0xc0, 0x09, 0xc0, 0x13, 0x00, 0x33, 0x00, 0x9d, 0x00, 0x9c, 0x00, 0x3d, 0x00, 0x3c, 0x00,
        0x35, 0x00, 0x2f, 0x00, 0xff, 0x01, 0x00, 0x01, 0x75, 0x00, 0x00, 0x00, 0x10, 0x00, 0x0e,
        0x00, 0x00, 0x0b, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x00,
        0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x16, 0x00, 0x14, 0x00, 0x1d,
        0x00, 0x17, 0x00, 0x1e, 0x00, 0x19, 0x00, 0x18, 0x01, 0x00, 0x01, 0x01, 0x01, 0x02, 0x01,
        0x03, 0x01, 0x04, 0x00, 0x10, 0x00, 0x0e, 0x00, 0x0c, 0x02, 0x68, 0x32, 0x08, 0x68, 0x74,
        0x74, 0x70, 0x2f, 0x31, 0x2e, 0x31, 0x00, 0x16, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00,
        0x31, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x30, 0x00, 0x2e, 0x04, 0x03, 0x05, 0x03, 0x06, 0x03,
        0x08, 0x07, 0x08, 0x08, 0x08, 0x1a, 0x08, 0x1b, 0x08, 0x1c, 0x08, 0x09, 0x08, 0x0a, 0x08,
        0x0b, 0x08, 0x04, 0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01, 0x03, 0x03,
        0x03, 0x01, 0x03, 0x02, 0x04, 0x02, 0x05, 0x02, 0x06, 0x02, 0x00, 0x2b, 0x00, 0x05, 0x04,
        0x03, 0x04, 0x03, 0x03, 0x00, 0x2d, 0x00, 0x02, 0x01, 0x01, 0x00, 0x33, 0x00, 0x26, 0x00,
        0x24, 0x00, 0x1d, 0x00, 0x20, 0xe0, 0x72, 0x9c, 0x10, 0x8c, 0x9a, 0x5e, 0xca, 0x0b, 0x3c,
        0x24, 0x97, 0xad, 0x7b, 0xda, 0x33, 0x6b, 0xb6, 0xb9, 0xc2, 0x0e, 0xcd, 0x24, 0x30, 0x09,
        0x92, 0x09, 0x75, 0x27, 0xec, 0x53, 0x01, 0x00, 0x15, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    const EXAMPLE_JA3: &str = "771,4866-4867-4865-49196-49200-159-52393-52392-52394-49195-49199-158-49188-49192-107-49187-49191-103-49162-49172-57-49161-49171-51-157-156-61-60-53-47-255,0-11-10-16-22-23-49-13-43-45-51-21,29-23-30-25-24-256-257-258-259-260,0-1-2";
    #[allow(dead_code)]
    const EXAMPLE_JA4: &str = "t13d3112h2_e8f1e7e78f70_6bebaf5329ac";
    #[allow(dead_code)]
    const EXAMPLE_JA4_R: &str = "t13d3112h2_002f,0033,0035,0039,003c,003d,0067,006b,009c,009d,009e,009f,00ff,1301,1302,1303,c009,c00a,c013,c014,c023,c024,c027,c028,c02b,c02c,c02f,c030,cca8,cca9,ccaa_000a,000b,000d,0015,0016,0017,002b,002d,0031,0033_0403,0503,0603,0807,0808,081a,081b,081c,0809,080a,080b,0804,0805,0806,0401,0501,0601,0303,0301,0302,0402,0502,0602";

    #[test]
    fn extract_client_hello_metadata() {
        let want = ClientHelloMetadata {
            //src_ip: IpAddr::from_str("2a02:3035:b16:e24b:7ea0:79a5:f672:97d1").unwrap(),
            //dst_ip: IpAddr::from_str("2606:2800:220:1:248:1893:25c8:1946").unwrap(),
            //src_port: 39140,
            //dst_port: 443,
            outer_version: 769,
            inner_version: 771,
            ciphers: vec![
                4866, 4867, 4865, 49196, 49200, 159, 52393, 52392, 52394, 49195, 49199, 158, 49188,
                49192, 107, 49187, 49191, 103, 49162, 49172, 57, 49161, 49171, 51, 157, 156, 61,
                60, 53, 47, 255,
            ],
            extensions: vec![0, 11, 10, 16, 22, 23, 49, 13, 43, 45, 51, 21],
            sni: "example.com".to_owned(),
            ec_curves: vec![29, 23, 30, 25, 24, 256, 257, 258, 259, 260],
            ec_curve_point_formats: vec![0, 1, 2],
            alpn: vec!["h2".to_string(), "http/1.1".to_string()],
        };

        let got = extract_client_hello(&EXAMPLE_TLS_PAYLOAD).expect("TLS header can be extracted");
        assert_eq!(got, want);
    }

    #[test]
    fn ja3() {
        assert_eq!(
            EXAMPLE_JA3,
            extract_client_hello(&EXAMPLE_TLS_PAYLOAD)
                .expect("TLS header can be extracted")
                .ja3()
        );
    }
}
